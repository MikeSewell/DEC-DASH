---
phase: 07-alert-configuration-persistence
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/alertConfig.ts
  - convex/alertDismissals.ts
  - convex/alerts.ts
autonomous: true
requirements: [ALRT-01, ALRT-02]

must_haves:
  truths:
    - "Alert thresholds (deadline days, budget variance %, sync staleness hours) are stored in a Convex alertConfig singleton table, not hardcoded"
    - "Admin/manager users can read and update alert config thresholds via Convex mutations"
    - "Per-user alert dismissals are stored in a Convex alertDismissals table keyed by userId + alertKey"
    - "The getAlerts query reads thresholds from alertConfig with hardcoded fallback defaults; dismissed alert filtering is performed client-side in WhatNeedsAttention.tsx using getMyDismissals"
  artifacts:
    - path: "convex/schema.ts"
      provides: "alertConfig and alertDismissals table definitions"
      contains: "alertConfig"
    - path: "convex/alertConfig.ts"
      provides: "get and update queries/mutations for alert thresholds"
      exports: ["get", "update"]
    - path: "convex/alertDismissals.ts"
      provides: "dismiss, undismiss, and getMyDismissals mutations/queries"
      exports: ["dismiss", "undismiss", "getMyDismissals"]
    - path: "convex/alerts.ts"
      provides: "getAlerts query using dynamic config thresholds from alertConfig table"
      exports: ["getAlerts"]
  key_links:
    - from: "convex/alerts.ts"
      to: "convex/schema.ts (alertConfig table)"
      via: "ctx.db.query('alertConfig').first()"
      pattern: "alertConfig.*first"
    - from: "convex/alertConfig.ts"
      to: "convex/users.ts"
      via: "requireRole('admin', 'manager') guard on update mutation"
      pattern: "requireRole"
---

<objective>
Add Convex backend tables, queries, and mutations for configurable alert thresholds and per-user alert dismissals.

Purpose: Transforms the hardcoded alerts system into a configurable, dismissible one — the backend foundation that the frontend admin tab and dismissal UI will consume.
Output: Four modified/created Convex files providing alertConfig CRUD, alertDismissals CRUD, and a refactored getAlerts query that uses dynamic config thresholds (dismissal filtering is client-side in Plan 07-02).
</objective>

<execution_context>
@/Users/mastermac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mastermac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@convex/schema.ts
@convex/alerts.ts
@convex/users.ts

<interfaces>
<!-- Key types and contracts the executor needs. -->

From convex/alerts.ts (current):
```typescript
export interface Alert {
  id: string;
  type: "deadline" | "budget" | "sync" | "integration";
  severity: "critical" | "warning" | "info";
  title: string;
  description: string;
  action?: { label: string; href: string };
  urgencyScore: number;
}

export const getAlerts = query({ handler: async (ctx): Promise<Alert[]> => { ... } });
```

From convex/users.ts:
```typescript
export async function requireRole(
  ctx: QueryCtx | MutationCtx,
  ...roles: Array<"admin" | "manager" | "staff" | "lawyer" | "psychologist" | "readonly">
): Promise<Doc<"users">>;

export const getCurrentUser = query({ ... });
```

Current hardcoded thresholds in alerts.ts:
- Deadline window: 30 days (thirtyDaysMs = 30 * 24 * 60 * 60 * 1000)
- Budget variance: 90% (pct < 0.9 threshold)
- QB sync staleness: 1 hour (60 * 60 * 1000)
- Sheets staleness: 2 hours (2 * 60 * 60 * 1000)
- Calendar staleness: 2 hours (2 * 60 * 60 * 1000)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add alertConfig and alertDismissals tables to schema + create CRUD modules</name>
  <files>convex/schema.ts, convex/alertConfig.ts, convex/alertDismissals.ts</files>
  <action>
**1. convex/schema.ts** — Add two new tables after `expenseAllocations`:

```typescript
alertConfig: defineTable({
  deadlineWindowDays: v.number(),      // default 30
  budgetVariancePct: v.number(),       // default 90 (means 90%)
  syncStalenessHours: v.number(),      // default 1 for QB, but this is the general threshold
  qbStalenessHours: v.number(),        // default 1
  sheetsStalenessHours: v.number(),    // default 2
  calendarStalenessHours: v.number(),  // default 2
  updatedAt: v.number(),
  updatedBy: v.optional(v.id("users")),
}),

alertDismissals: defineTable({
  userId: v.id("users"),
  alertKey: v.string(),                // matches Alert.id (e.g. "deadline-{grantId}-Q1 Report")
  dismissedAt: v.number(),
}).index("by_userId", ["userId"])
  .index("by_userId_alertKey", ["userId", "alertKey"]),
```

**2. convex/alertConfig.ts** — New file with get query + update mutation:

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { requireRole } from "./users";

// Default thresholds used when no config row exists
export const ALERT_DEFAULTS = {
  deadlineWindowDays: 30,
  budgetVariancePct: 90,
  qbStalenessHours: 1,
  sheetsStalenessHours: 2,
  calendarStalenessHours: 2,
} as const;

export const get = query({
  handler: async (ctx) => {
    const config = await ctx.db.query("alertConfig").first();
    if (!config) return ALERT_DEFAULTS;
    return {
      deadlineWindowDays: config.deadlineWindowDays,
      budgetVariancePct: config.budgetVariancePct,
      qbStalenessHours: config.qbStalenessHours,
      sheetsStalenessHours: config.sheetsStalenessHours,
      calendarStalenessHours: config.calendarStalenessHours,
    };
  },
});

export const update = mutation({
  args: {
    deadlineWindowDays: v.number(),
    budgetVariancePct: v.number(),
    qbStalenessHours: v.number(),
    sheetsStalenessHours: v.number(),
    calendarStalenessHours: v.number(),
  },
  handler: async (ctx, args) => {
    await requireRole(ctx, "admin", "manager");
    const existing = await ctx.db.query("alertConfig").first();
    if (existing) {
      await ctx.db.patch(existing._id, { ...args, updatedAt: Date.now(), updatedBy: (await requireRole(ctx, "admin", "manager"))._id });
    } else {
      await ctx.db.insert("alertConfig", { ...args, updatedAt: Date.now() });
    }
  },
});
```

Note: The `update` mutation calls `requireRole` which already returns the user. Store `updatedBy` from the first `requireRole` call — refactor to avoid double call:
```typescript
handler: async (ctx, args) => {
  const user = await requireRole(ctx, "admin", "manager");
  const existing = await ctx.db.query("alertConfig").first();
  const data = { ...args, updatedAt: Date.now(), updatedBy: user._id };
  if (existing) {
    await ctx.db.patch(existing._id, data);
  } else {
    await ctx.db.insert("alertConfig", data);
  }
},
```

**3. convex/alertDismissals.ts** — New file with dismiss, undismiss, getMyDismissals:

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { getAuthUserId } from "@convex-dev/auth/server";

export const dismiss = mutation({
  args: { alertKey: v.string() },
  handler: async (ctx, { alertKey }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");
    // Check if already dismissed
    const existing = await ctx.db
      .query("alertDismissals")
      .withIndex("by_userId_alertKey", (q) => q.eq("userId", userId).eq("alertKey", alertKey))
      .first();
    if (existing) return; // already dismissed
    await ctx.db.insert("alertDismissals", { userId, alertKey, dismissedAt: Date.now() });
  },
});

export const undismiss = mutation({
  args: { alertKey: v.string() },
  handler: async (ctx, { alertKey }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");
    const existing = await ctx.db
      .query("alertDismissals")
      .withIndex("by_userId_alertKey", (q) => q.eq("userId", userId).eq("alertKey", alertKey))
      .first();
    if (existing) await ctx.db.delete(existing._id);
  },
});

export const getMyDismissals = query({
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return [];
    const dismissals = await ctx.db
      .query("alertDismissals")
      .withIndex("by_userId", (q) => q.eq("userId", userId))
      .collect();
    return dismissals.map((d) => d.alertKey);
  },
});
```

Note: `getMyDismissals` returns a simple string array of dismissed alertKeys — the frontend uses this to filter the alerts list client-side. This separation keeps `getAlerts` a public query that doesn't require auth (it returns all alerts; filtering is done client-side with the dismissals data).
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx tsc --noEmit convex/schema.ts convex/alertConfig.ts convex/alertDismissals.ts 2>&1 | head -30 || npm run build 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `alertConfig` and `alertDismissals` tables defined in schema.ts
    - `convex/alertConfig.ts` exports `get` query and `update` mutation with requireRole guard
    - `convex/alertDismissals.ts` exports `dismiss`, `undismiss`, `getMyDismissals`
    - All files compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor getAlerts to read dynamic thresholds from alertConfig table</name>
  <files>convex/alerts.ts</files>
  <action>
Modify the existing `getAlerts` query in `convex/alerts.ts` to read thresholds from the `alertConfig` singleton table instead of using hardcoded values. Import `ALERT_DEFAULTS` from `./alertConfig` to use as fallback when no config row exists.

**Changes to make:**

1. At top of handler, load config:
```typescript
const configRow = await ctx.db.query("alertConfig").first();
const config = {
  deadlineWindowDays: configRow?.deadlineWindowDays ?? 30,
  budgetVariancePct: configRow?.budgetVariancePct ?? 90,
  qbStalenessHours: configRow?.qbStalenessHours ?? 1,
  sheetsStalenessHours: configRow?.sheetsStalenessHours ?? 2,
  calendarStalenessHours: configRow?.calendarStalenessHours ?? 2,
};
```

2. **Section A (deadline alerts):** Replace `const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;` with:
```typescript
const windowMs = config.deadlineWindowDays * 24 * 60 * 60 * 1000;
```
And update the `dateMs > now + thirtyDaysMs` check to use `windowMs`.

3. **Section B (budget variance):** Replace `if (pct < 0.9) continue;` with:
```typescript
if (pct < config.budgetVariancePct / 100) continue;
```
Keep the `pct >= 1.0` critical threshold unchanged (always flag 100%+ as critical).

4. **Section C (QB staleness):** Replace `if (qbAgeMs > 60 * 60 * 1000)` with:
```typescript
if (qbAgeMs > config.qbStalenessHours * 60 * 60 * 1000)
```
Update the description to use `config.qbStalenessHours` in the threshold text.

5. **Section E (Sheets staleness):** Replace `if (now - latestSheetSync > 2 * 60 * 60 * 1000)` with:
```typescript
if (now - latestSheetSync > config.sheetsStalenessHours * 60 * 60 * 1000)
```
Update the description threshold text accordingly.

6. **Section F (Calendar staleness):** Replace `if (now - calConfig.lastSyncAt > 2 * 60 * 60 * 1000)` with:
```typescript
if (now - calConfig.lastSyncAt > config.calendarStalenessHours * 60 * 60 * 1000)
```
Update the description threshold text accordingly.

Do NOT import ALERT_DEFAULTS from alertConfig.ts — inline the fallback values directly using `??` operator. This avoids a cross-file import that would require alertConfig.ts to export a non-query/mutation constant (Convex modules export queries/mutations; importing plain constants between them is fine but the `??` inline approach is simpler and avoids any circular dependency risk).

Keep the Alert interface export and getAlerts query export unchanged in shape — only thresholds change from hardcoded to dynamic.
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npm run build 2>&1 | tail -10</automated>
  </verify>
  <done>
    - `getAlerts` reads thresholds from `alertConfig` table with inline `??` fallback defaults
    - All 5 threshold points (deadline window, budget variance, QB staleness, Sheets staleness, Calendar staleness) use dynamic config values
    - Alert interface and export shape unchanged
    - Next.js production build passes
  </done>
</task>

</tasks>

<verification>
1. `convex/schema.ts` contains `alertConfig` and `alertDismissals` table definitions
2. `convex/alertConfig.ts` has `get` and `update` exports
3. `convex/alertDismissals.ts` has `dismiss`, `undismiss`, `getMyDismissals` exports
4. `convex/alerts.ts` loads config from `alertConfig` table at start of `getAlerts` handler
5. All hardcoded threshold values (30 days, 90%, 1h, 2h, 2h) replaced with config-driven values
6. `npm run build` passes
</verification>

<success_criteria>
- alertConfig singleton table stores all 5 configurable thresholds
- alertDismissals table stores per-user per-alertKey dismissals with compound index
- getAlerts query dynamically reads config (falls back to defaults if no config row)
- requireRole("admin", "manager") guards the alertConfig update mutation
- getMyDismissals returns string[] of dismissed alert keys for authenticated user
- Production build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/07-alert-configuration-persistence/07-01-SUMMARY.md`
</output>
