---
phase: 03-google-calendar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/googleCalendarActions.ts
  - convex/googleCalendarInternal.ts
  - convex/googleCalendarSync.ts
  - convex/googleCalendar.ts
  - src/types/index.ts
autonomous: true
requirements: [CAL-01]

must_haves:
  truths:
    - "googleCalendarConfig and googleCalendarCache tables exist in Convex schema with correct fields and indexes"
    - "googleCalendarActions.ts syncCalendars fetches events from Google Calendar API using service account auth (same env vars as Sheets)"
    - "googleCalendarInternal.ts provides getFullConfig internalQuery, upsertEvent/clearCalendarEvents/updateLastSync internalMutations"
    - "googleCalendarSync.ts runSync internalAction checks config and calls syncCalendars (cron entrypoint)"
    - "googleCalendar.ts exposes getConfig query, getEvents query (filters by_startAt index for today + 8 days window), and saveConfig mutation"
    - "DashboardSectionId type in src/types/index.ts includes 'calendar'"
  artifacts:
    - convex/googleCalendarActions.ts
    - convex/googleCalendarInternal.ts
    - convex/googleCalendarSync.ts
    - convex/googleCalendar.ts
  key_links:
    - "googleCalendarActions.ts uses 'use node' directive and imports googleapis"
    - "googleCalendarSync.ts calls internal.googleCalendarInternal.getFullConfig then internal.googleCalendarActions.syncCalendars"
    - "googleCalendar.ts getEvents returns null when not configured (three-state pattern: undefined = loading, null = not configured, data = events)"
---

<objective>
Create the complete Google Calendar backend: schema tables, Convex module family (actions/internal/sync/public), and extend the DashboardSectionId type.

Purpose: Establish the data foundation that Plan 02 (cron + admin UI) and Plan 03 (dashboard widget) both depend on.
Output: 5 new Convex files + schema additions + type extension. Calendar sync is functional via code but not yet wired to cron or UI.
</objective>

<execution_context>
@/Users/mastermac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mastermac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-google-calendar-integration/03-RESEARCH.md

@convex/schema.ts
@convex/googleSheetsActions.ts
@convex/googleSheetsInternal.ts
@convex/googleSheetsSync.ts
@convex/googleSheets.ts
@src/types/index.ts

<interfaces>
<!-- Key types and contracts the executor needs -->

From convex/schema.ts (existing pattern to follow):
```typescript
// Singleton config tables: googleSheetsConfig uses .first() queries
// Cache tables: grantsCache, quickbooksCache have lastSyncAt fields
// Index patterns: .index("by_fieldName", ["fieldName"])
```

From convex/googleSheetsActions.ts (auth pattern to mirror):
```typescript
"use node";
// imports googleapis via dynamic import: const { google } = await import("googleapis");
// Auth: new google.auth.GoogleAuth({ credentials: { client_email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL, private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, "\n") }, scopes: [...] })
```

From convex/googleSheetsSync.ts (cron entrypoint pattern):
```typescript
// internalAction runSync: checks config via internal query, then calls internal action
```

From convex/googleSheets.ts (public module pattern):
```typescript
// query getConfig: returns null if not configured, stripped fields otherwise
// mutation saveConfig: delete existing + insert fresh (singleton pattern)
```

From src/types/index.ts (type to extend):
```typescript
export type DashboardSectionId = "executive-snapshot" | "grant-budget" | "grant-tracking" | "donation-performance" | "profit-loss" | "programs-coparent" | "programs-legal" | "client-activity";
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema tables and extend DashboardSectionId type</name>
  <files>convex/schema.ts, src/types/index.ts</files>
  <action>
**In `convex/schema.ts`**, add two new tables after the `constantContactConfig` table definition (keeping them grouped with other Google integrations):

```typescript
googleCalendarConfig: defineTable({
  calendars: v.array(v.object({
    calendarId: v.string(),
    displayName: v.string(),
  })),
  lastSyncAt: v.optional(v.number()),
  configuredBy: v.id("users"),
}),

googleCalendarCache: defineTable({
  eventId: v.string(),
  calendarId: v.string(),
  calendarDisplayName: v.string(),
  summary: v.string(),
  startAt: v.number(),
  endAt: v.number(),
  isAllDay: v.boolean(),
  location: v.optional(v.string()),
  htmlLink: v.optional(v.string()),
  lastSyncAt: v.number(),
})
  .index("by_eventId_calendarId", ["eventId", "calendarId"])
  .index("by_startAt", ["startAt"])
  .index("by_calendarId", ["calendarId"]),
```

**In `src/types/index.ts`**, add `"calendar"` to the `DashboardSectionId` union type:
```typescript
export type DashboardSectionId =
  | "executive-snapshot"
  | "grant-budget"
  | "grant-tracking"
  | "donation-performance"
  | "profit-loss"
  | "programs-coparent"
  | "programs-legal"
  | "client-activity"
  | "calendar";
```
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - `googleCalendarConfig` table defined with `calendars` array, `lastSyncAt`, and `configuredBy` fields
    - `googleCalendarCache` table defined with all event fields, `isAllDay` boolean, and three indexes (`by_eventId_calendarId`, `by_startAt`, `by_calendarId`)
    - `DashboardSectionId` includes `"calendar"` as a valid value
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex module family (actions, internal, sync, public)</name>
  <files>convex/googleCalendarActions.ts, convex/googleCalendarInternal.ts, convex/googleCalendarSync.ts, convex/googleCalendar.ts</files>
  <action>
**Create `convex/googleCalendarInternal.ts`** — internalQuery + internalMutations:

```typescript
import { internalQuery, internalMutation } from "./_generated/server";
import { v } from "convex/values";

export const getFullConfig = internalQuery({
  handler: async (ctx) => {
    return await ctx.db.query("googleCalendarConfig").first();
  },
});

export const upsertEvent = internalMutation({
  args: {
    eventId: v.string(),
    calendarId: v.string(),
    calendarDisplayName: v.string(),
    summary: v.string(),
    startAt: v.number(),
    endAt: v.number(),
    isAllDay: v.boolean(),
    location: v.optional(v.string()),
    htmlLink: v.optional(v.string()),
    lastSyncAt: v.number(),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("googleCalendarCache")
      .withIndex("by_eventId_calendarId", (q) =>
        q.eq("eventId", args.eventId).eq("calendarId", args.calendarId)
      )
      .first();
    if (existing) {
      await ctx.db.patch(existing._id, args);
    } else {
      await ctx.db.insert("googleCalendarCache", args);
    }
  },
});

export const clearCalendarEvents = internalMutation({
  args: { calendarId: v.string() },
  handler: async (ctx, args) => {
    const events = await ctx.db
      .query("googleCalendarCache")
      .withIndex("by_calendarId", (q) => q.eq("calendarId", args.calendarId))
      .collect();
    for (const event of events) {
      await ctx.db.delete(event._id);
    }
  },
});

export const updateLastSync = internalMutation({
  args: { configId: v.id("googleCalendarConfig") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.configId, { lastSyncAt: Date.now() });
  },
});
```

**Create `convex/googleCalendarActions.ts`** — MUST start with `"use node";` on line 1:

```typescript
"use node";

import { internalAction, action } from "./_generated/server";
import { internal } from "./_generated/api";

export const syncCalendars = internalAction({
  handler: async (ctx) => {
    const { google } = await import("googleapis");

    const config = await ctx.runQuery(internal.googleCalendarInternal.getFullConfig);
    if (!config) throw new Error("Google Calendar not configured");

    const auth = new google.auth.GoogleAuth({
      credentials: {
        client_email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
        private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, "\n"),
      },
      scopes: ["https://www.googleapis.com/auth/calendar.readonly"],
    });

    const calendar = google.calendar({ version: "v3", auth });

    const now = new Date();
    const timeMin = now.toISOString();
    const timeMax = new Date(now.getTime() + 8 * 24 * 60 * 60 * 1000).toISOString();

    for (const { calendarId, displayName } of config.calendars) {
      try {
        const response = await calendar.events.list({
          calendarId,
          timeMin,
          timeMax,
          singleEvents: true,
          orderBy: "startTime",
          maxResults: 100,
          showDeleted: false,
        });

        const events = response.data.items ?? [];

        // Clear stale events for this calendar before re-inserting
        await ctx.runMutation(internal.googleCalendarInternal.clearCalendarEvents, { calendarId });

        for (const event of events) {
          if (!event.id || !event.summary) continue;
          const isAllDay = Boolean(event.start?.date && !event.start?.dateTime);
          await ctx.runMutation(internal.googleCalendarInternal.upsertEvent, {
            eventId: event.id,
            calendarId,
            calendarDisplayName: displayName,
            summary: event.summary,
            startAt: isAllDay
              ? new Date(event.start!.date!).getTime()
              : new Date(event.start!.dateTime!).getTime(),
            endAt: isAllDay
              ? new Date(event.end!.date!).getTime()
              : new Date(event.end!.dateTime!).getTime(),
            isAllDay,
            location: event.location ?? undefined,
            htmlLink: event.htmlLink ?? undefined,
            lastSyncAt: Date.now(),
          });
        }
      } catch (err) {
        // Per-calendar errors logged but don't abort other calendars
        console.error(`Failed to sync calendar ${calendarId}:`, err);
      }
    }

    await ctx.runMutation(internal.googleCalendarInternal.updateLastSync, { configId: config._id });
  },
});

// Public action — allows admin UI "Sync Now" button
export const triggerSync = action({
  handler: async (ctx) => {
    await ctx.runAction(internal.googleCalendarActions.syncCalendars, {});
  },
});
```

**Create `convex/googleCalendarSync.ts`** — cron entrypoint:

```typescript
import { internalAction } from "./_generated/server";
import { internal } from "./_generated/api";

export const runSync = internalAction({
  handler: async (ctx) => {
    const config = await ctx.runQuery(internal.googleCalendarInternal.getFullConfig);
    if (!config || config.calendars.length === 0) {
      console.log("Google Calendar not configured, skipping sync");
      return;
    }
    try {
      await ctx.runAction(internal.googleCalendarActions.syncCalendars, {});
      console.log("Google Calendar sync completed");
    } catch (error) {
      console.error("Google Calendar sync failed:", error);
    }
  },
});
```

**Create `convex/googleCalendar.ts`** — public queries + mutations:

```typescript
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// Get config status (public — for admin UI and widget three-state check)
export const getConfig = query({
  handler: async (ctx) => {
    const config = await ctx.db.query("googleCalendarConfig").first();
    if (!config) return null;
    return {
      _id: config._id,
      calendars: config.calendars,
      lastSyncAt: config.lastSyncAt,
    };
  },
});

// Get events for dashboard widget (today + 7 days)
export const getEvents = query({
  handler: async (ctx) => {
    const config = await ctx.db.query("googleCalendarConfig").first();
    if (!config || config.calendars.length === 0) return null;

    const todayStart = new Date();
    todayStart.setHours(0, 0, 0, 0);
    const windowEnd = todayStart.getTime() + 8 * 24 * 60 * 60 * 1000;

    const events = await ctx.db
      .query("googleCalendarCache")
      .withIndex("by_startAt", (q) =>
        q.gte("startAt", todayStart.getTime()).lt("startAt", windowEnd)
      )
      .order("asc")
      .collect();

    return { events, lastSyncAt: config.lastSyncAt ?? null };
  },
});

// Save config (singleton pattern — patch or insert)
export const saveConfig = mutation({
  args: {
    calendars: v.array(v.object({
      calendarId: v.string(),
      displayName: v.string(),
    })),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db.query("googleCalendarConfig").first();
    if (existing) {
      await ctx.db.patch(existing._id, { calendars: args.calendars });
    } else {
      await ctx.db.insert("googleCalendarConfig", {
        calendars: args.calendars,
        configuredBy: "" as any, // matches Sheets pattern — no auth context in mutation
      });
    }
  },
});
```

Key patterns to follow:
- `"use node"` ONLY on `googleCalendarActions.ts` (the file that imports `googleapis`)
- Dynamic `import("googleapis")` inside the handler (same as `googleSheetsActions.ts`)
- `getEvents` returns `null` when not configured (widget uses this for three-state: `undefined` = loading, `null` = not configured, `{events, lastSyncAt}` = data)
- `clearCalendarEvents` runs per-calendar before re-inserting, so one calendar failure doesn't wipe another's data
- `saveConfig` uses patch-or-insert (not delete-then-insert) to preserve `lastSyncAt` and `configuredBy` across saves
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - All four Convex files exist and compile without TypeScript errors
    - `googleCalendarActions.ts` starts with `"use node"` and uses the exact same auth pattern as `googleSheetsActions.ts`
    - `googleCalendar.ts` `getEvents` query filters by `by_startAt` index with 8-day window and returns `null` when not configured
    - `googleCalendarSync.ts` `runSync` checks config before calling syncCalendars
    - `googleCalendarInternal.ts` has all four functions: `getFullConfig`, `upsertEvent`, `clearCalendarEvents`, `updateLastSync`
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — all new files compile, DashboardSectionId includes "calendar"
2. `convex/schema.ts` has both `googleCalendarConfig` and `googleCalendarCache` tables with correct indexes
3. All four new Convex files exist with correct module exports
4. `googleCalendarActions.ts` line 1 is `"use node";`
5. `getEvents` query returns `null` (not `undefined`, not empty array) when not configured
</verification>

<success_criteria>
- Schema has `googleCalendarConfig` (with `calendars` array) and `googleCalendarCache` (with 3 indexes) tables
- Complete 4-file Convex module family mirroring Google Sheets pattern
- `DashboardSectionId` type includes `"calendar"`
- TypeScript compiles with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-google-calendar-integration/03-01-SUMMARY.md`
</output>
