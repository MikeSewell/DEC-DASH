---
phase: 04-proactive-alerts-panel
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/alerts.ts
autonomous: true
requirements:
  - ALRT-01
  - ALRT-02
  - ALRT-03

must_haves:
  truths:
    - "Grant deadlines within 30 days produce deadline-type alerts with days-remaining counts"
    - "Grants with >90% budget spent produce budget-type alerts with percentage and dollar amounts"
    - "QuickBooks cache older than 1 hour produces a sync staleness alert"
    - "Google Sheets config with lastSyncAt older than 2 hours produces a sync staleness alert"
    - "Missing QuickBooks config produces an integration-missing alert"
    - "Alerts are sorted by urgencyScore descending (most urgent first)"
    - "Each data source read is null-safe — missing sources skip their alert category without crashing"
  artifacts:
    - path: "convex/alerts.ts"
      provides: "Alert type definition + getAlerts query"
      exports: ["Alert", "getAlerts"]
  key_links:
    - from: "convex/alerts.ts"
      to: "grants table"
      via: "ctx.db.query('grants').collect()"
      pattern: "query.*grants.*collect"
    - from: "convex/alerts.ts"
      to: "grantsCache table"
      via: "ctx.db.query('grantsCache').collect()"
      pattern: "query.*grantsCache.*collect"
    - from: "convex/alerts.ts"
      to: "quickbooksCache table"
      via: "ctx.db.query('quickbooksCache').withIndex('by_fetchedAt').order('desc').first()"
      pattern: "quickbooksCache.*by_fetchedAt.*desc.*first"
    - from: "convex/alerts.ts"
      to: "quickbooksConfig table"
      via: "ctx.db.query('quickbooksConfig').first()"
      pattern: "quickbooksConfig.*first"
    - from: "convex/alerts.ts"
      to: "googleSheetsConfig table"
      via: "ctx.db.query('googleSheetsConfig').first()"
      pattern: "googleSheetsConfig.*first"
    - from: "convex/alerts.ts"
      to: "googleCalendarConfig table"
      via: "ctx.db.query('googleCalendarConfig').first()"
      pattern: "googleCalendarConfig.*first"
---

<objective>
Build `convex/alerts.ts` — a single Convex query that reads grants, grantsCache, quickbooksCache, quickbooksConfig, googleSheetsConfig, and googleCalendarConfig to compute a ranked `Alert[]` array. This is the server-side aggregation layer for all proactive alerts.

Purpose: Centralizes alert computation on the server. One round-trip, server-side urgency ranking, null-safe per data source. Replaces the current 3-query fan-out in WhatNeedsAttention.tsx with a single data contract.

Output: `convex/alerts.ts` with exported `Alert` interface and `getAlerts` query.
</objective>

<execution_context>
@/Users/mastermac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mastermac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-proactive-alerts-panel/04-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From convex/schema.ts — grants table (relevant fields):
```typescript
grants: defineTable({
  grantKey: v.string(),
  fundingStage: v.string(),
  fundingSource: v.string(),
  programName: v.optional(v.string()),
  amountAwarded: v.optional(v.number()),
  q1ReportDate: v.optional(v.string()),   // ISO date strings
  q2ReportDate: v.optional(v.string()),
  q3ReportDate: v.optional(v.string()),
  q4ReportDate: v.optional(v.string()),
  // ...
}).index("by_grantKey", ["grantKey"]).index("by_fundingStage", ["fundingStage"])
```

From convex/schema.ts — grantsCache table:
```typescript
grantsCache: defineTable({
  sheetRowId: v.string(),
  grantName: v.string(),
  funder: v.string(),
  totalAmount: v.number(),
  amountSpent: v.optional(v.number()),
  status: v.union(v.literal("active"), v.literal("pending"), v.literal("completed"), v.literal("cultivating")),
  lastSyncAt: v.number(),
}).index("by_sheetRowId", ["sheetRowId"])
```

From convex/schema.ts — quickbooksCache table:
```typescript
quickbooksCache: defineTable({
  reportType: v.string(),
  data: v.string(),
  fetchedAt: v.number(),
  // ...
}).index("by_reportType", ["reportType"]).index("by_fetchedAt", ["fetchedAt"])
```

From convex/schema.ts — quickbooksConfig table:
```typescript
quickbooksConfig: defineTable({
  accessToken: v.string(),
  refreshToken: v.string(),
  realmId: v.string(),
  tokenExpiry: v.number(),
  connectedAt: v.number(),
  // ...
})
```

From convex/schema.ts — googleSheetsConfig table:
```typescript
googleSheetsConfig: defineTable({
  spreadsheetId: v.string(),
  lastSyncAt: v.optional(v.number()),
  // ...
}).index("by_purpose", ["purpose"])
```

From convex/schema.ts — googleCalendarConfig table:
```typescript
googleCalendarConfig: defineTable({
  calendars: v.array(v.object({ calendarId: v.string(), displayName: v.string() })),
  lastSyncAt: v.optional(v.number()),
  configuredBy: v.id("users"),
})
```

From convex/grants.ts — getUpcomingDeadlines (reference pattern, inline the logic):
```typescript
export const getUpcomingDeadlines = query({
  handler: async (ctx) => {
    const allGrants = await ctx.db.query("grants").collect();
    const now = new Date();
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    // iterates q1-q4ReportDate fields, checks if within now..thirtyDaysFromNow
  }
});
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create convex/alerts.ts with Alert interface and getAlerts query</name>
  <files>convex/alerts.ts</files>
  <action>
Create a new file `convex/alerts.ts` with the following structure:

**1. Export the `Alert` interface:**
```typescript
export interface Alert {
  id: string;                                            // deterministic, e.g. "deadline-{grant._id}-Q1 Report"
  type: "deadline" | "budget" | "sync" | "integration";
  severity: "critical" | "warning" | "info";
  title: string;
  description: string;
  action?: { label: string; href: string };
  urgencyScore: number;                                  // higher = more urgent, used for descending sort
}
```

**2. Export `getAlerts` as a Convex `query` with no args:**

The handler reads 6 tables and computes alerts. Each section is independently null-safe — if a table read returns null or empty, skip that alert category. DO NOT let one failed source crash the entire query.

**Section A — ALRT-01: Grant deadline alerts (30-day window):**
- `const allGrants = await ctx.db.query("grants").collect();`
- `const now = Date.now();`
- `const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;`
- For each grant, check `q1ReportDate`, `q2ReportDate`, `q3ReportDate`, `q4ReportDate` (ISO date strings).
- Parse each with `new Date(dateStr).getTime()`. If the date is >= now AND <= now + thirtyDaysMs, create an alert.
- `daysLeft = Math.ceil((dateMs - now) / 86400000)`
- severity: `daysLeft <= 7 ? "critical" : "warning"`
- urgencyScore: `1000 - daysLeft` (sooner deadlines rank higher)
- id: `deadline-${grant._id}-${reportLabel}` (deterministic, uses Convex doc ID)
- title: `${reportLabel} Due — ${grant.fundingSource ?? "Grant"}`
- description: `${grant.programName ?? ""} report due in ${daysLeft} day${daysLeft === 1 ? "" : "s"}`
- action: `{ label: "View Grant", href: "/grants" }`

**Section B — ALRT-02: Budget variance alerts (>90% threshold):**
- `const cachedGrants = await ctx.db.query("grantsCache").collect();`
- For each cached grant where `amountSpent !== undefined && totalAmount > 0`:
  - `const pct = amountSpent / totalAmount;`
  - If `pct >= 0.9`, create an alert.
  - severity: `pct >= 1.0 ? "critical" : "warning"`
  - urgencyScore: `pct >= 1.0 ? 900 : 800`
  - id: `budget-${g._id}` (use Convex doc _id, not sheetRowId — _id is unique)
  - title: `Budget Alert — ${g.grantName}`
  - description: `${Math.round(pct * 100)}% of budget spent ($${g.amountSpent!.toLocaleString()} of $${g.totalAmount.toLocaleString()})`
  - action: `{ label: "View Budget", href: "/grants" }`

**Section C — ALRT-03: QuickBooks sync staleness:**
- `const qbCache = await ctx.db.query("quickbooksCache").withIndex("by_fetchedAt").order("desc").first();`
- If qbCache exists: compute `qbAgeMs = now - qbCache.fetchedAt`. If `> 60 * 60 * 1000` (1 hour):
  - severity: "warning", urgencyScore: 500
  - id: "sync-qb-stale"
  - title: "QuickBooks Data Is Stale"
  - description: `` `Last synced ${Math.floor(qbAgeMs / 3600000)}h ${Math.floor((qbAgeMs % 3600000) / 60000)}m ago` ``
  - action: `{ label: "Admin", href: "/admin" }`

**Section D — ALRT-03: QuickBooks not connected:**
- `const qbConfig = await ctx.db.query("quickbooksConfig").first();`
- If `!qbConfig`:
  - severity: "warning", urgencyScore: 400
  - id: "integration-qb-missing"
  - title: "QuickBooks Not Connected"
  - description: "Financial data unavailable — connect QuickBooks to see expenses, P&L, and cash on hand."
  - action: `{ label: "Connect", href: "/admin" }`
- Else if qbConfig exists and `qbConfig.tokenExpiry < now` (token expired):
  - severity: "warning", urgencyScore: 450
  - id: "integration-qb-expired"
  - title: "QuickBooks Token Expired"
  - description: "Your QuickBooks session has expired. Reconnect to restore financial data sync."
  - action: `{ label: "Reconnect", href: "/admin" }`

**Section E — ALRT-03: Google Sheets sync staleness:**
- `const sheetsConfigs = await ctx.db.query("googleSheetsConfig").collect();`
- Find the most recent lastSyncAt across all config rows: `const latestSheetSync = Math.max(...sheetsConfigs.map(c => c.lastSyncAt ?? 0));`
- If `latestSheetSync > 0` AND `now - latestSheetSync > 2 * 60 * 60 * 1000` (2 hours):
  - severity: "info", urgencyScore: 300
  - id: "sync-sheets-stale"
  - title: "Google Sheets Data Is Stale"
  - description: `` `Last synced ${Math.floor((now - latestSheetSync) / 3600000)}h ago (threshold: 2h)` ``
  - action: `{ label: "Admin", href: "/admin" }`

**Section F — ALRT-03: Google Calendar sync staleness:**
- `const calConfig = await ctx.db.query("googleCalendarConfig").first();`
- If calConfig?.lastSyncAt AND `now - calConfig.lastSyncAt > 2 * 60 * 60 * 1000`:
  - severity: "info", urgencyScore: 250
  - id: "sync-calendar-stale"
  - title: "Google Calendar Data Is Stale"
  - description: `` `Last synced ${Math.floor((now - calConfig.lastSyncAt) / 3600000)}h ago (threshold: 2h)` ``
  - action: `{ label: "Admin", href: "/admin" }`

**Final sort:** `alerts.sort((a, b) => b.urgencyScore - a.urgencyScore);`

**Return:** `return alerts;`

**Import only from Convex:**
```typescript
import { query } from "./_generated/server";
```

No `"use node"` directive — this is a pure Convex query, no npm packages needed.

**IMPORTANT pitfall avoidance:**
- Use `qbCache.fetchedAt` for QB staleness, NOT `qbConfig.connectedAt` (connectedAt is when connected, not when last synced)
- Use Convex document `_id` in alert IDs for uniqueness — never use display names
- Use `Date.now()` for `now` (not `new Date()`) — Convex queries can use epoch ms directly
- `toLocaleString()` works in Convex server runtime for number formatting
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx tsc --noEmit convex/alerts.ts 2>&1 | head -20</automated>
  </verify>
  <done>convex/alerts.ts exists with exported Alert interface and getAlerts query. TypeScript compiles without errors in the file. Query reads 6 tables, computes alerts for deadlines, budget, sync staleness, and integration status, sorts by urgencyScore descending.</done>
</task>

<task type="auto">
  <name>Task 2: Deploy Convex and verify getAlerts query is accessible</name>
  <files>convex/_generated/api.d.ts</files>
  <action>
Run `npx convex dev --once` to deploy the new alerts.ts query to Convex. This regenerates `convex/_generated/api.d.ts` to include `api.alerts.getAlerts`.

After deployment, verify the generated API types include the alerts module:
- Check that `convex/_generated/api.d.ts` contains a reference to the `alerts` module
- The `getAlerts` query should be accessible as `api.alerts.getAlerts`

If `npx convex dev --once` fails with an auth error in non-interactive terminal (known issue from STATE.md), note it in the summary as a known blocker — the user must run it interactively. Proceed with TypeScript-only verification in that case.
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && grep -q "alerts" convex/_generated/api.d.ts && echo "alerts module found in generated API" || echo "alerts module NOT found — run npx convex dev --once interactively"</automated>
  </verify>
  <done>Convex deployment succeeds and `api.alerts.getAlerts` is available in the generated API types. If deployment requires interactive auth, TypeScript compilation of alerts.ts passes and the file is ready for deployment.</done>
</task>

</tasks>

<verification>
1. `convex/alerts.ts` exists and exports `Alert` interface + `getAlerts` query
2. TypeScript compiles: `npx tsc --noEmit convex/alerts.ts` produces no errors
3. Query reads grants, grantsCache, quickbooksCache, quickbooksConfig, googleSheetsConfig, googleCalendarConfig
4. Each table read is null-safe (wrapped in existence checks, no crashes on empty data)
5. Alerts sorted by urgencyScore descending
6. Alert IDs use Convex document `_id` for uniqueness (not display names)
7. QB staleness uses `fetchedAt` from quickbooksCache (not `connectedAt` from quickbooksConfig)
</verification>

<success_criteria>
- `convex/alerts.ts` is a valid Convex query module with no TypeScript errors
- The `getAlerts` query produces Alert[] covering all 4 alert categories: deadline, budget, sync, integration
- Each alert category can independently return empty results without affecting other categories
- Alerts are urgency-ranked: deadline (sooner = higher) > budget (over > approaching) > sync QB > integration > sync sheets > sync calendar
</success_criteria>

<output>
After completion, create `.planning/phases/04-proactive-alerts-panel/04-01-SUMMARY.md`
</output>
