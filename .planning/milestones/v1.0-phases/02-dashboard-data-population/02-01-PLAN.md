---
phase: 02-dashboard-data-population
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/quickbooksActions.ts
  - convex/clients.ts
  - convex/grants.ts
  - src/lib/utils.ts
autonomous: true
requirements: [DASH-01, CMD-01, CMD-02]

must_haves:
  truths:
    - "QB token refresh preserves existing refresh token when API omits it"
    - "formatDollars is importable from @/lib/utils for any component"
    - "clients.getStatsByProgram returns per-program active counts with role filtering"
    - "grants.getUpcomingDeadlines returns grant name and deadline date for reports due in 30 days"
  artifacts:
    - path: "convex/quickbooksActions.ts"
      provides: "Safe QB token refresh"
      contains: "token.refresh_token || config.refreshToken"
    - path: "src/lib/utils.ts"
      provides: "Shared formatDollars utility"
      exports: ["formatDollars"]
    - path: "convex/clients.ts"
      provides: "Per-program client stats query"
      exports: ["getStatsByProgram"]
    - path: "convex/grants.ts"
      provides: "Upcoming grant deadlines query"
      exports: ["getUpcomingDeadlines"]
  key_links:
    - from: "convex/quickbooksActions.ts"
      to: "convex/quickbooksInternal.ts"
      via: "updateTokens mutation"
      pattern: "refreshToken.*\\|\\|.*config\\.refreshToken"
    - from: "convex/clients.ts getStatsByProgram"
      to: "programs table + clients table"
      via: "join programId to program type"
      pattern: "getStatsByProgram"
---

<objective>
Fix QB token refresh safety, extract shared utilities, and add backend queries needed by new dashboard components.

Purpose: The token refresh bug is a latent production risk that must be fixed before trusting QB data on the dashboard. The new Convex queries (getStatsByProgram, getUpcomingDeadlines) and shared formatDollars utility are prerequisites for the WhatNeedsAttention panel and ClientActivity section built in Plan 02-03.

Output: Safe QB token persistence, shared formatDollars in utils, two new Convex queries
</objective>

<execution_context>
@/Users/mastermac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mastermac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-dashboard-data-population/02-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. -->

From convex/quickbooksActions.ts (refreshTokens, lines 8-38):
```typescript
export const refreshTokens = internalAction({
  handler: async (ctx) => {
    // ... oauthClient.refresh() ...
    const token = authResponse.getJson();
    await ctx.runMutation(internal.quickbooksInternal.updateTokens, {
      configId: config._id,
      accessToken: token.access_token,
      refreshToken: token.refresh_token,  // BUG: may be undefined/empty
      tokenExpiry: Date.now() + token.expires_in * 1000,
    });
  },
});
```

From convex/quickbooksInternal.ts (updateTokens):
```typescript
export const updateTokens = internalMutation({
  args: {
    configId: v.id("quickbooksConfig"),
    accessToken: v.string(),
    refreshToken: v.string(),
    tokenExpiry: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.configId, {
      accessToken: args.accessToken,
      refreshToken: args.refreshToken,
      tokenExpiry: args.tokenExpiry,
    });
  },
});
```

From convex/clients.ts (getStats, lines 111-143):
```typescript
export const getStats = query({
  args: {},
  handler: async (ctx) => {
    // ... role-based filtering ...
    return { total, active, newThisMonth };
  },
});
```

From convex/grants.ts (getStats, lines 27-63):
```typescript
export const getStats = query({
  args: {},
  handler: async (ctx) => {
    // ... loops grants, counts by stage, sums awarded, counts upcoming reports ...
    return { total, byStage, totalAwarded, upcomingReports };
  },
});
```

From src/lib/utils.ts:
```typescript
export function formatCurrency(amount: number): string { ... }
export function formatCurrencyExact(amount: number): string { ... }
export function timeAgo(timestamp: number): string { ... }
```

From src/components/dashboard/ExecutiveSnapshot.tsx (formatDollars, lines 51-59 — LOCAL function):
```typescript
function formatDollars(amount: number): string {
  if (amount >= 1_000_000) return `$${(amount / 1_000_000).toFixed(1)}M`;
  if (amount >= 1_000) return `$${(amount / 1_000).toFixed(0)}K`;
  return `$${amount.toLocaleString("en-US", { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
}
```

From convex/_generated/api (relevant exports):
```typescript
api.quickbooks.getConfig  // returns null | { _id, realmId, companyName, connectedAt, isExpired }
api.clients.getStats      // returns { total, active, newThisMonth }
api.grants.getStats       // returns { total, byStage, totalAwarded, upcomingReports }
api.grants.list           // returns Grant[]
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix QB token refresh and extract formatDollars to shared utils</name>
  <files>
    convex/quickbooksActions.ts
    src/lib/utils.ts
    src/components/dashboard/ExecutiveSnapshot.tsx
  </files>
  <action>
**QB Token Fix (convex/quickbooksActions.ts):**

In the `refreshTokens` internalAction (line 8), change the `refreshToken` field in the `updateTokens` call (line 35) from:
```
refreshToken: token.refresh_token,
```
to:
```
refreshToken: token.refresh_token || config.refreshToken,
```

This ensures that when QB's OAuth API omits `refresh_token` from the response (which happens when the existing token is still valid), we preserve the existing `config.refreshToken` instead of saving `undefined`/empty string. The `config` variable is already available in scope (line 11).

**Extract formatDollars to shared utils (src/lib/utils.ts):**

Add the `formatDollars` function at the end of `src/lib/utils.ts`, after the `getInitials` function:
```typescript
// Format dollars compactly ($45.2K, $1.3M) for dashboard cards
export function formatDollars(amount: number): string {
  if (amount >= 1_000_000) {
    return `$${(amount / 1_000_000).toFixed(1)}M`;
  }
  if (amount >= 1_000) {
    return `$${(amount / 1_000).toFixed(0)}K`;
  }
  return `$${amount.toLocaleString("en-US", { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`;
}
```

**Update ExecutiveSnapshot import (src/components/dashboard/ExecutiveSnapshot.tsx):**

1. Remove the local `formatDollars` function (lines 51-59)
2. Add `formatDollars` to the import from `@/lib/utils`:
   ```
   import { cn, formatDollars } from "@/lib/utils";
   ```
   (Remove the separate `import { cn } from "@/lib/utils"` line if it exists, and merge into one import)
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
  </verify>
  <done>
    - QB refreshTokens uses `token.refresh_token || config.refreshToken` fallback
    - formatDollars exported from @/lib/utils
    - ExecutiveSnapshot imports formatDollars from @/lib/utils (no local copy)
    - TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add getStatsByProgram query to clients and getUpcomingDeadlines to grants</name>
  <files>
    convex/clients.ts
    convex/grants.ts
  </files>
  <action>
**Add getStatsByProgram to convex/clients.ts:**

Add a new exported query after the existing `getStats` query (after line 143). This query returns per-program-type active client counts with role-based filtering:

```typescript
/**
 * Get active client counts grouped by program type (legal, coparent, other).
 * Role-filtered: lawyers see legal only, psychologists see coparent only.
 */
export const getStatsByProgram = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");
    const user = await ctx.db.get(userId);
    if (!user) throw new Error("User not found");

    const programs = await ctx.db.query("programs").collect();
    const programMap = new Map(programs.map((p) => [p._id, p.type]));

    let clients = await ctx.db.query("clients").collect();

    // Role-based filtering (mirrors getStats)
    if (user.role === "lawyer") {
      const legalIds = new Set(
        programs.filter((p) => p.type === "legal").map((p) => p._id)
      );
      clients = clients.filter((c) => c.programId && legalIds.has(c.programId));
    } else if (user.role === "psychologist") {
      const coparentIds = new Set(
        programs.filter((p) => p.type === "coparent").map((p) => p._id)
      );
      clients = clients.filter((c) => c.programId && coparentIds.has(c.programId));
    }

    const activeClients = clients.filter((c) => c.status === "active");
    const byType: Record<string, number> = {};
    for (const client of activeClients) {
      const type = client.programId ? (programMap.get(client.programId) ?? "other") : "other";
      byType[type] = (byType[type] ?? 0) + 1;
    }

    return {
      legal: byType["legal"] ?? 0,
      coparent: byType["coparent"] ?? 0,
      other: byType["other"] ?? 0,
    };
  },
});
```

**Add getUpcomingDeadlines to convex/grants.ts:**

Add a new exported query after `getStats` (after line 63). This returns grants with report dates in the next 30 days, for the WhatNeedsAttention panel:

```typescript
/**
 * Get grants with upcoming report deadlines (within 30 days).
 * Returns grant name, funder, and specific deadline date for display in attention panel.
 */
export const getUpcomingDeadlines = query({
  args: {},
  handler: async (ctx) => {
    const allGrants = await ctx.db.query("grants").collect();
    const now = new Date();
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

    const upcoming: { grantId: string; fundingSource: string; programName: string; deadlineDate: string; reportLabel: string }[] = [];

    for (const grant of allGrants) {
      const quarters = [
        { date: grant.q1ReportDate, label: "Q1 Report" },
        { date: grant.q2ReportDate, label: "Q2 Report" },
        { date: grant.q3ReportDate, label: "Q3 Report" },
        { date: grant.q4ReportDate, label: "Q4 Report" },
      ];

      for (const q of quarters) {
        if (q.date) {
          const d = new Date(q.date);
          if (d >= now && d <= thirtyDaysFromNow) {
            upcoming.push({
              grantId: grant._id,
              fundingSource: grant.fundingSource ?? "Unknown Funder",
              programName: grant.programName ?? "Unknown Program",
              deadlineDate: q.date,
              reportLabel: q.label,
            });
          }
        }
      }
    }

    // Sort by soonest deadline first
    upcoming.sort((a, b) => new Date(a.deadlineDate).getTime() - new Date(b.deadlineDate).getTime());

    return upcoming;
  },
});
```

Note: The `grants` table fields used (`q1ReportDate`, `q2ReportDate`, `q3ReportDate`, `q4ReportDate`, `fundingSource`, `programName`) are the Excel-imported rich fields — already confirmed in schema. `_id` is the Convex document ID (type `Id<"grants">`).
  </action>
  <verify>
    <automated>cd "/Users/mastermac/Desktop/DEC-DASH 2.0" && npx convex dev --once 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `clients.getStatsByProgram` query deployed and returns `{ legal, coparent, other }` counts
    - `grants.getUpcomingDeadlines` query deployed and returns sorted array of `{ grantId, fundingSource, programName, deadlineDate, reportLabel }`
    - Both queries compile and deploy to Convex without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes — no TypeScript errors
2. `npx convex dev --once` deploys successfully — new queries registered
3. QB refreshTokens action has the `|| config.refreshToken` fallback
4. `formatDollars` is exported from `src/lib/utils.ts`
5. `ExecutiveSnapshot.tsx` imports `formatDollars` from utils (no local definition)
</verification>

<success_criteria>
- QB token refresh is safe against blank refresh token responses
- formatDollars is a shared utility available to all dashboard components
- Backend queries for ClientActivity (getStatsByProgram) and WhatNeedsAttention (getUpcomingDeadlines) are deployed and callable
- All code compiles and deploys cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-dashboard-data-population/02-01-SUMMARY.md`
</output>
